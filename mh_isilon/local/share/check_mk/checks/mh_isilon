#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
# Description:  checks EMC isilon
#
# Maintainer:   thomas.tretbar@managedhosting.de
#
# Version:      1.0
#
# Created:      2018-06
#
# Usage:        
#
# Changelog:    2018-06 - initial release - thomas.tretbar@managedhosting.de
#
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
#
def human_readable_to_bytes(size):
      bytes = size[:-1]
      unit = size[-1]
      bytes = float(bytes)
      if (unit == "T"):
         bytes *= 1099511627776
      elif (unit == 'G'):
         bytes *= 1073741824
      elif (unit == 'M'):
         bytes *= 1048576
      elif (unit == 'K'):
         bytes *= 1024
      elif (unit == 'B'):
         bytes *= 1
      else:
         bytes = 0
      bytes = saveint(bytes)
      return bytes

#<<<synciq>>>
#m10000h10022 sync Yes 1528826401 86400 Customer: managedhosting.de - Veeam Backup Share (de-dd-srv-1057)
#m10000h10024 sync Yes 1524230285 99999999 Customer: managedhosting.de - Test Share SyncIQ Failover
#m10186h10006 sync Yes 1528857901 86400 Customer: Facelift - remote backup (share uploads)
#m10186h10028 sync Yes 1528873201 86400 Customer: Facelift BBT - Backup Share (de-dd-srv-1258)
#m10312h10002 sync Yes 1528880401 86400 Customer: Eligo - Data Share (de-dd-srv-1152)
#m10312h10009 sync Yes 1528844401 86400 Customer: Eligo - Backup Share (de-dd-srv-1583)
#
#<Name>  <Type> <Enabled> <last success epoch> <maxage in sec> <description (may have whitespace)>"
#


#
# default for acceptable delay in minutes
# can be overwritten by WATO rule
#
factory_settings["mh_synciq"] = {
    "synciq_delay"     : 360,
}

#
# inventorize name
#
def inventory_mh_synciq(checkname, info):
    for line in info:
        name = line[0]
        yield name, {}

#
# check function
#
def check_mh_synciq(item, params, info):
    now = int(time.time())

    for line in info:
        name = line[0]

        if item == name:
           lastrun = int(line[3])
           maxage = int(line[4])
           description = ' '.join(line[6:])

           delay = params["synciq_delay"]

           age = now - lastrun
           checkage = age - (delay * 60)

           infotext = "Isilon SyncIQ: " + name + ", last: " + get_age_human_readable(age) + " ago"

           if checkage > maxage:
               stateval = 1
               infotext += "(!), schedule: " + get_age_human_readable(maxage) 
           else:
               stateval = 0

           infotext += ", descr: " + description
                

           #
           # return everything
           #
           return stateval, infotext



check_info["synciq"] = {
        "check_function"            : check_mh_synciq,
        "service_description"       : "Isilon SyncIQ %s",
        "has_perfdata"              : False,
        "default_levels_variable"   : "mh_synciq",
        "inventory_function"        : inventory_mh_synciq,
        "group"                     : "mh_synciq",

}


#<<<isilon_cluster>>>
#de-dd-sto-1028 6.2M 139M 41.4T 111T 70.0T OK
#<name> <in_bps> <out_bps> <hdd_used> <hdd_total> <hdd_avail> <status>

#
# inventorize name
#
def inventory_mh_isilon_cluster(checkname, info):
    for line in info:
        name = line[0]
        yield name, {}


def check_mh_isilon_cluster(item, params, info):

    for line in info:
        name = line[0]

        if item == name:
            stateval = 0
            perfdata = []
            isi_hdd_used = (line[3])
            isi_hdd_total = (line[4])
            isi_hdd_avail = line[5]
            status = ' '.join(line[6:])


            
            if status == "OK":
                infotext = "Isilon cluster name: " + name
            else:
                infotext = "Isilon cluster " + name
                stateval = 1
                infotext += " status: " + status +"(!)"
            
            isi_hdd_used_bytes = saveint(human_readable_to_bytes(isi_hdd_used))
            isi_hdd_total_bytes = saveint(human_readable_to_bytes(isi_hdd_total))
            isi_hdd_avail_bytes = saveint(human_readable_to_bytes(isi_hdd_avail))

            #freepercentage = str((isi_hdd_avail_bytes - isi_hdd_used_bytes) * 100 / isi_hdd_avail_bytes)
            usedpercentage = str(isi_hdd_used_bytes * 100 / isi_hdd_avail_bytes)

            infotext += ", capacity used: " + usedpercentage + "% (total / avail / used: " + isi_hdd_total + " / " + isi_hdd_avail + " / " + isi_hdd_used + ")"

            perfdata.append(("fs_size", isi_hdd_avail_bytes))
            perfdata.append(("fs_used", isi_hdd_used_bytes))
            perfdata.append(("fs_provisioning", isi_hdd_total_bytes))

            return stateval, infotext, perfdata

check_info["isilon_cluster"] = {
        "check_function"            : check_mh_isilon_cluster,
        "service_description"       : "Isilon Cluster %s",
        "has_perfdata"              : True,
        "inventory_function"        : inventory_mh_isilon_cluster,

}


#<<<isilon_node>>>
#1 35.1M 304M 13.4T 39.7T 10.100.57.1 0 48 28 OK
#2 549k 3.5M 13.4T 39.7T 10.100.57.2 0 48 27 OK
#3 95.6M 16.0M 13.4T 39.7T 10.100.57.3 0 47 27 OK

#<id> <in_bps> <out_bps> <hdd_used> <hdd_total> <IP> <failed_disks> <PSU temp> <temp> <status>

#
# default for acceptable temperatures
# can be overwritten by WATO rule
#
factory_settings["mh_isilon_node"] = {
    "psu_temp_warn"     : 60,
    "isi_temp_warn"     : 40,
}


def inventory_mh_isilon_node(checkname, info):
    for line in info:
        name = line[0]
        yield name, {}

def check_mh_isilon_node(item, params, info):

    for line in info:
        name = line[0]

        if item == name:
            degree_sign= u'\N{DEGREE SIGN}'
            perfdata = []
            psu_temp_warn = params["psu_temp_warn"]
            isi_temp_warn = params["isi_temp_warn"]

            status = ' '.join(line[9:])
            infotext = "Isilon node ID: " + name
            if status == "OK":
                stateval = 0
            else:
                stateval = 1
                infotext += " status: " + status + "(!)"

            psu_temp = saveint(line[7])
            if psu_temp > psu_temp_warn:
                stateval = 1
                infotext += ", PSU temperature: " + str(psu_temp) + degree_sign + "C(!)"

            temp = saveint(line[8])
            if temp > isi_temp_warn:
                stateval = 1
                infotext += ", system temperature: " + str(temp) + degree_sign + "C(!)"

            failed_disks = saveint(line[6])
            if failed_disks > 0:
                stateval = 2
                infotext += ", failed disks: " + str(failed_disks) + "(!!)"
                


            ip = line[5]
            infotext += ", IP: " + ip

            isi_hdd_used = (line[3])
            isi_hdd_used_bytes = saveint(human_readable_to_bytes(isi_hdd_used))

            isi_hdd_total = (line[4])
            isi_hdd_total_bytes = saveint(human_readable_to_bytes(isi_hdd_total))

            usedpercentage = str(isi_hdd_used_bytes * 100 / isi_hdd_total_bytes)

            perfdata.append(("fs_size", isi_hdd_total_bytes))
            perfdata.append(("fs_used", isi_hdd_used_bytes))
            perfdata.append(("isi_temp", temp))
            perfdata.append(("isi_psu_temp", psu_temp))

            infotext += ", disk used: " + usedpercentage + "% (total / used: " + isi_hdd_total + " / " + isi_hdd_used + ")"

            return stateval, infotext, perfdata




check_info["isilon_node"] = {
        "check_function"            : check_mh_isilon_node,
        "service_description"       : "Isilon Node-%s",
        "has_perfdata"              : True,
        "default_levels_variable"   : "mh_isilon_node",
        "inventory_function"        : inventory_mh_isilon_node,
        "group"                     : "mh_isilon_node"
}

#
# NFS Stats
#
def inventory_mh_isilon_pstat_nfs(checkname, info):
    for line in info:
        name = line[0]
        yield name, {}

def check_mh_isilon_pstat_nfs(item, params, info):

    for line in info:
        name = line[0]

        if item == name:
            perfdata = []
            stateval = 0

            infotext = "Isilon Statistics:"

            # line[25] NFS3 total
            nfsv3_ios = (saveint(float(line[25])))
            perfdata.append(("nfsv3_ios", nfsv3_ios))
            infotext += " NFSv3: " + str(nfsv3_ios) + " IO/s"

            # line[29/30/31] is MB/s
            # line[29] OneFS In
            # line[30] OneFS Out
            # line[31] OneFS Total
            isi_ifs_in_MB = line[29]
            isi_ifs_in_bps = human_readable_to_bytes(isi_ifs_in_MB + "M")
            isi_ifs_out_MB = line[30]
            isi_ifs_out_bps = human_readable_to_bytes(isi_ifs_out_MB + "M")
            isi_ifs_total_MB = line[31]
            perfdata.append(("isi_ifs_in_bps", isi_ifs_in_bps))
            perfdata.append(("isi_ifs_out_bps", isi_ifs_out_bps))
            onefsinfo = ', OneFS in/out/total: %0.1f/%0.1f/%0.1f MB/s' % (float(isi_ifs_in_MB), float(isi_ifs_out_MB), float(isi_ifs_total_MB))
            infotext += onefsinfo

            # line[32] Net In MB/s
            # line[33] Net In Pkt/s
            # line[34] Net In Errors/s
            # line[35] Net Out MB/s
            # line[36] Net Out Pkt/s
            # line[37] Net Out Errors/s
            isi_if_in_MB = line[32]
            isi_if_in_bps = human_readable_to_bytes(isi_if_in_MB + "M") * 8
            isi_if_out_MB = line[35]
            isi_if_out_bps = human_readable_to_bytes(isi_if_out_MB + "M") * 8
            isi_inerr = saveint(float(line[34]))
	    isi_outerr = saveint(float(line[37]))
            isi_inucast = saveint(float(line[33]))
            isi_outucast = saveint(float(line[36]))
            perfdata.append(("isi_if_in_bps", isi_if_in_bps))
            perfdata.append(("isi_if_out_bps", isi_if_out_bps))
            perfdata.append(("isi_inerr", isi_inerr))
            perfdata.append(("isi_outerr", isi_outerr))
            perfdata.append(("isi_inucast", isi_inucast))
            perfdata.append(("isi_outucast", isi_outucast))
 
            netinfo = ", Network"
            
            if isi_outerr > 0 or isi_inerr > 0:
                stateval = 1
                netinfo += " packet errors per sec in/out: %d/%d(!)," % (isi_inerr, isi_outerr)

            netinfo += " in/out: %0.1f/%0.1f MB/s" % (float(isi_if_in_MB), float(isi_if_out_MB))
            infotext += netinfo
            # 

            # line[38] Disk IOPs
            # line[39] Disk Read MB/s
            # line[40] Disk Write MB/s
            isi_disk_ios  = saveint(float(line[38]))
            isi_disk_read_throughput = line[29]
            isi_disk_write_throughput = line[30]
            perfdata.append(("isi_disk_ios", isi_disk_ios))
           
            diskinfo = ", Disk %d IO/s, read/write: %0.1f/%0.1f MB/s" % (isi_disk_ios, float(isi_disk_read_throughput), float(isi_disk_write_throughput))
            infotext += diskinfo

            # MByte to Byte
            isi_disk_read_throughput = human_readable_to_bytes(isi_disk_read_throughput + "M")
            isi_disk_write_throughput = human_readable_to_bytes(isi_disk_write_throughput + "M")

            perfdata.append(("isi_disk_read_throughput", isi_disk_read_throughput))
            perfdata.append(("isi_disk_write_throughput", isi_disk_write_throughput))


            #
            return stateval, infotext, perfdata


check_info["isilon_pstat_nfs"] = {
        "check_function"            : check_mh_isilon_pstat_nfs,
        "service_description"       : "Isilon Statistics %s",
        "has_perfdata"              : True,
        "inventory_function"        : inventory_mh_isilon_pstat_nfs,
}


# isi_cpu

# Output is node plus info like linux /proc/loadavg plus the number of cores:
# <isilon node> 0.26 0.47 0.52 2/459 19531 4


cpuload_default_levels = (5.0, 10.0)

def inventory_isi_cpu(info):
    for line in info:
        name = line[0]
        yield name, "cpuload_default_levels"

def check_isi_cpu(item, params, info):
    if not info:
        return

    for line in info:
        name = line[0]

        if item == name:

            num_cpus = int(line[6])

            load = map(float, line[1:4])
            return check_cpu_load_generic(params, load, num_cpus)

check_info["isi_cpu"] = {
    "check_function"          : check_isi_cpu,
    "inventory_function"      : inventory_isi_cpu,
    "service_description"     : "CPU load %s",
    "has_perfdata"            : True,
    "includes"                : ["cpu_load.include"],
    "handle_real_time_checks" : True,
}



# Example output from agent:
# <<<isi_uptime>>>
# <isilon node> 15876.96 187476.72


def inventory_isi_uptime(info):
   for line in info:
        name = line[0]
        yield name, {}



def check_isi_uptime(item, params, info):
    for line in info:
        name = line[0]
        if item == name:
            uptime_sec = float(line[1])
            return check_uptime_seconds(params, uptime_sec)


check_info["isi_uptime"] = {
    'check_function'      : check_isi_uptime,
    'inventory_function'  : inventory_isi_uptime,
    'service_description' : 'Uptime %s',
    'has_perfdata'        : True,
    'includes'            : [ 'uptime.include' ],
    'group'               : 'isi_uptime',
}


# isi_ram

# Example output from agent:
#<<<isi_mem>>>
#Node-1 51422355456 23548067840
#Node-2 51422355456 23226458112
#Node-3 51422355456 22477946880
#<node> <total> <avail>


def inventory_isi_mem(info):
    for line in info:
        name = line[0]
        yield name, {}

def check_isi_mem(item, params, info):
    if not info:
        return

    for line in info:

        name = line[0]
        if item == name:

            isi_mem_total = saveint(line[1])
            isi_mem_avail = saveint(line[2])
            isi_mem_used = isi_mem_total - isi_mem_avail
            stateval = 0
            perfdata = []

            usedpercentage = str(isi_mem_used * 100 / isi_mem_total)
            infotext = "RAM used: " + get_bytes_human_readable(isi_mem_used) + " of " + get_bytes_human_readable(isi_mem_total) + " (" + usedpercentage + "%)"
            #infotext = "RAM used: "

            perfdata.append(("isi_mem_total", isi_mem_total))
            perfdata.append(("isi_mem_avail", isi_mem_avail))


            return stateval, infotext, perfdata

check_info["isi_mem"] = {
    "check_function"          : check_isi_mem,
    "inventory_function"      : inventory_isi_mem,
    "service_description"     : "Memory %s",
    "has_perfdata"            : True,
    "handle_real_time_checks" : True,
}


# isi_quota

# example agent output:
#directory DEFAULT    /ifs/m10137/h10001 No    100.00G -     -    54.805G
#directory DEFAULT    /ifs/m10186/h10006 No    4.39T   -     -    4.2945T
#directory DEFAULT    /ifs/m10186/h10004 No    250.00G -     -    185.1k
#
# fields
#Type      AppliesTo  Path               Snap  Hard    Soft  Adv  Used


factory_settings["mh_isi_quota"] = {
    "quota_warn"     : 97,
    "quota_crit"     : 99,
}


def inventory_mh_isi_quota(info):
    if info:
        yield "", "mh_isi_quota"

def check_mh_isi_quota(item, params, info):
    stateval = 0
    count = 0
    hard = 0
    soft = 0
    warnings = 0
    criticals = 0
    quota_warn = params["quota_warn"]
    quota_crit = params["quota_crit"]
    crittext = ""
    warntext = ""
    infocrit=""
    infowarn=""

    for line in info:
        path = line[2]
        quota = 0
        count += 1

        # hard quota
        if line[4] != "-":
            hard += 1
            quota_hr = line[4]
            if quota_hr == "0":
                quota = saveint(quota_hr)
            else:
                quota = saveint(human_readable_to_bytes(quota_hr))

        # soft quota
        if line[5] != "-":
            soft += 1
            quota_hr = line[5]
            if quota_hr == "0":
                quota = saveint(quota_hr)
            else:
                quota = saveint(human_readable_to_bytes(quota_hr))

        # used
        used_hr = line[7]
        if used_hr == "0":
            used = saveint(used_hr)
        else:
            used = human_readable_to_bytes(used_hr)

        usedpercentage = used * 100 / quota

        # evaluate
        if usedpercentage >= quota_crit:
           criticals += 1
           crittext += "\n(!!) %s (%d%% of %s)" % (path, usedpercentage, quota_hr)
        elif usedpercentage >= quota_warn:
           warnings += 1
           warntext += "\n(!) %s (%d%% of %s)" % (path, usedpercentage, quota_hr)


    infotext = "Isilon: %d quotas (%d hard, %d soft) active" % (count, hard, soft)

    s=""
    if warnings != 0:
        if warnings > 1:
            s="s"
        infowarn += ", %d quota%s exceeding warning threshold of %d%%(!)" % (warnings, s, quota_warn)
        stateval = 1

    s=""
    if criticals != 0:
        if criticals > 1:
            s="s"
        infocrit += ", %d quota%s exceeding critical threshold of %d%%(!!)" % (criticals, s, quota_crit)
        stateval = 2
    
    if warnings == 0 and criticals == 0:
        infotext += ", all within thresholds (%s/%s%%)\n(.) no quota exceeding threshold" % (quota_warn, quota_crit)

    infotext += infocrit + infowarn + crittext + warntext

    return stateval, infotext


check_info["isi_quota"] = {
        "check_function"            : check_mh_isi_quota,
        "service_description"       : "Isilon Quota",
        "has_perfdata"              : False,
        "default_levels_variable"   : "mh_isi_quota",
        "inventory_function"        : inventory_mh_isi_quota,
        "group"                     : "mh_isi_quota",

}

